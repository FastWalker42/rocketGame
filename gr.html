<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0"
    />
    <title>Анимированный график на весь фон</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
        background-color: #0a0a0a;
        color: white;
        overflow: hidden;
        height: 100vh;
      }

      .controls {
        position: fixed;
        top: 20px;
        left: 20px;
        z-index: 100;
        background: rgba(0, 0, 0, 0.7);
        padding: 20px;
        border-radius: 10px;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(0, 255, 0, 0.3);
      }

      .slider-container {
        margin: 10px 0;
        width: 300px;
      }

      .slider {
        width: 100%;
        height: 15px;
        background: rgba(0, 255, 0, 0.2);
        outline: none;
        border-radius: 10px;
      }

      .slider::-webkit-slider-thumb {
        appearance: none;
        width: 25px;
        height: 25px;
        border-radius: 50%;
        background: #00ff00;
        cursor: pointer;
        box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
      }

      .value-display {
        text-align: center;
        font-size: 24px;
        margin: 15px 0;
        color: #00ff00;
        text-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
      }

      canvas {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        display: block;
      }

      h1 {
        margin: 0 0 15px 0;
        color: #00ff00;
        text-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        font-size: 18px;
      }
    </style>
  </head>
  <body>
    <div class="controls">
      <h1>Анимированный график</h1>

      <div class="slider-container">
        <input
          type="range"
          min="0"
          max="100"
          value="50"
          class="slider"
          id="valueSlider"
        />
      </div>

      <div class="value-display">
        Значение: <span id="currentValue">50</span>
      </div>
    </div>

    <canvas id="graphCanvas"></canvas>

    <script>
      class FullScreenGraph {
        constructor(canvasId, duration = 5000) {
          this.canvas = document.getElementById(canvasId)
          this.ctx = this.canvas.getContext('2d')
          this.duration = duration
          this.data = []
          this.startTime = Date.now()
          this.animationId = null
          this.hueShift = 0

          this.resizeCanvas()
          window.addEventListener('resize', () => this.resizeCanvas())

          this.initializeData()
          this.animate()
        }

        resizeCanvas() {
          this.canvas.width = window.innerWidth
          this.canvas.height = window.innerHeight
          this.draw()
        }

        initializeData() {
          const initialValue = 50
          const now = Date.now()

          // Создаем больше точек для плавности
          for (let i = 0; i < 200; i++) {
            const time = now - (this.duration * (200 - i)) / 200
            this.data.push({
              time: time,
              value: initialValue,
            })
          }
        }

        updateValue(value) {
          const now = Date.now()

          this.data.push({
            time: now,
            value: value,
          })

          const cutoffTime = now - this.duration
          this.data = this.data.filter(
            (point) => point.time >= cutoffTime
          )
        }

        draw() {
          const ctx = this.ctx
          const width = this.canvas.width
          const height = this.canvas.height
          const now = Date.now()
          const cutoffTime = now - this.duration

          // Очистка canvas с полупрозрачным фоном для эффекта шлейфа
          ctx.fillStyle = 'rgba(10, 10, 10, 0.1)'
          ctx.fillRect(0, 0, width, height)

          if (this.data.length < 2) return

          // Анимируем оттенок зеленого
          this.hueShift = (this.hueShift + 0.5) % 360
          const baseHue = 120 // Зеленый
          const animatedHue =
            (baseHue +
              Math.sin((this.hueShift * Math.PI) / 180) * 20) %
            360

          // Создаем основной градиент для линии
          const gradient = ctx.createLinearGradient(0, 0, width, 0)
          gradient.addColorStop(
            0,
            `hsla(${animatedHue}, 100%, 50%, 0.4)`
          )
          gradient.addColorStop(
            0.5,
            `hsla(${animatedHue}, 100%, 70%, 0.8)`
          )
          gradient.addColorStop(
            1,
            `hsla(${animatedHue}, 100%, 50%, 0.4)`
          )

          // Рисуем основную линию
          ctx.beginPath()

          const firstPoint = this.data[0]
          const x0 =
            ((firstPoint.time - cutoffTime) / this.duration) * width
          const y0 = height - (firstPoint.value / 100) * height
          ctx.moveTo(x0, y0)

          // Рисуем плавную кривую через все точки
          for (let i = 1; i < this.data.length; i++) {
            const point = this.data[i]
            const x =
              ((point.time - cutoffTime) / this.duration) * width
            const y = height - (point.value / 100) * height
            ctx.lineTo(x, y)
          }

          // Стиль основной линии
          ctx.strokeStyle = gradient
          ctx.lineWidth = 4
          ctx.lineJoin = 'round'
          ctx.lineCap = 'round'
          ctx.stroke()

          // Добавляем свечение
          ctx.shadowColor = `hsla(${animatedHue}, 100%, 50%, 0.6)`
          ctx.shadowBlur = 20
          ctx.stroke()
          ctx.shadowBlur = 0

          // Создаем заполнение с градиентом
          ctx.lineTo(width, height)
          ctx.lineTo(0, height)
          ctx.closePath()

          const fillGradient = ctx.createLinearGradient(
            0,
            0,
            0,
            height
          )
          fillGradient.addColorStop(
            0,
            `hsla(${animatedHue}, 100%, 50%, 0.15)`
          )
          fillGradient.addColorStop(
            0.5,
            `hsla(${animatedHue}, 100%, 30%, 0.08)`
          )
          fillGradient.addColorStop(
            1,
            `hsla(${animatedHue}, 100%, 10%, 0.02)`
          )

          ctx.fillStyle = fillGradient
          ctx.fill()

          // Добавляем дополнительные эффекты
          this.drawParticles()
        }

        drawParticles() {
          const ctx = this.ctx
          const width = this.canvas.width
          const height = this.canvas.height
          const now = Date.now()

          // Рисуем частицы вдоль линии
          if (this.data.length > 1) {
            for (let i = 0; i < this.data.length; i += 3) {
              const point = this.data[i]
              const cutoffTime = now - this.duration
              const x =
                ((point.time - cutoffTime) / this.duration) * width
              const y = height - (point.value / 100) * height

              // Только для видимой части
              if (x >= 0 && x <= width) {
                const size = Math.random() * 3 + 2
                const alpha = Math.random() * 0.3 + 0.1

                ctx.beginPath()
                ctx.arc(x, y, size, 0, Math.PI * 2)
                ctx.fillStyle = `rgba(0, 255, 0, ${alpha})`
                ctx.fill()
              }
            }
          }
        }

        animate() {
          this.draw()
          this.animationId = requestAnimationFrame(() =>
            this.animate()
          )
        }
      }

      // Инициализация
      document.addEventListener('DOMContentLoaded', () => {
        const graph = new FullScreenGraph('graphCanvas')
        const slider = document.getElementById('valueSlider')
        const valueDisplay = document.getElementById('currentValue')

        slider.addEventListener('input', (e) => {
          const value = parseInt(e.target.value)
          valueDisplay.textContent = value
          graph.updateValue(value)
        })

        // Плавное обновление графика
        setInterval(() => {
          graph.updateValue(parseInt(slider.value))
        }, 40)

        // Добавляем интерактивность - изменение значения при клике на фон
        document.addEventListener('click', (e) => {
          if (
            e.target === document.body ||
            e.target === graph.canvas
          ) {
            const rect = graph.canvas.getBoundingClientRect()
            const value =
              100 - ((e.clientY - rect.top) / rect.height) * 100
            slider.value = Math.max(0, Math.min(100, value))
            valueDisplay.textContent = Math.round(value)
            graph.updateValue(value)
          }
        })
      })
    </script>
  </body>
</html>
